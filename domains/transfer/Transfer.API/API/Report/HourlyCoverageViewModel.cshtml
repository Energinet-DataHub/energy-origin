@using API.Transfer.Api.Services
@model _Page_Report_HourlyCoverageViewModel_cshtml.HourlyCoverageViewModel
@{
    var HourlyConsumption = Model.ConsumptionHours
        .OrderBy(ch => ch.HourOfDay)
        .Select(ch => (double)ch.KwhQuantity)
        .ToArray();

    var HourlyMatched    = Model.Matched;
    var HourlyUnmatched  = Model.Unmatched;
    var HourlyOvermatched= Model.Overmatched;
}
public double[] HourlyUnmatched { get; set; }
public double[] HourlyOvermatched { get; set; }
public double[] HourlyConsumption { get; set; }
}
@{
    const int SvgW = 754, SvgH = 400;
    const int MarginLeft = 10, MarginTop = 10, PlotHeight = 304;
    double chartWidth = SvgW - 2 * MarginLeft;
    double chartHeight = PlotHeight;
    double maxValue = new[] { HourlyConsumption.Max(),
        HourlyMatched.Zip(HourlyUnmatched, (m, u) => m + u).Concat(HourlyOvermatched).Max() }.Max();
    double unitW = chartWidth / 24;
}
<svg class="highcharts-root" xmlns="http://www.w3.org/2000/svg"
     viewBox="0 0 @SvgW @SvgH" preserveAspectRatio="xMidYMid meet"
     style="width:100%;height:auto;display:block;">
    <defs>
        <clipPath id="chart-area">
            <rect x="0" y="0" width="@chartWidth" height="@chartHeight" fill="none" />
        </clipPath>
    </defs>
    <rect fill="#F9FAFB" x="0" y="0" width="@SvgW" height="@SvgH" />
    <rect fill="none" x="@MarginLeft" y="@MarginTop" width="@chartWidth" height="@chartHeight" />

    @* Grid lines *@
    <g clip-path="url(#chart-area)">
        @for (int i = 0; i <= 24; i++)
        {
            var x = MarginLeft + unitW * i;
            <line x1="@x" y1="@MarginTop" x2="@x" y2="@(MarginTop + chartHeight)" stroke="#e6e6e6" />
        }
    </g>

    @* Bars *@
    <g clip-path="url(#chart-area)" transform="translate(@MarginLeft,@MarginTop)">
        @for (int h = 0; h < 24; h++)
        {
            double x0 = unitW * h + unitW * 0.1;
            double yBase = chartHeight;
            var layers = new[] {
                (Value: HourlyMatched[h], Color: "#82CF76"),
                (Value: HourlyUnmatched[h], Color: "#DFDFDF"),
                (Value: HourlyOvermatched[h], Color: "#59ACE8")
            };
            foreach (var layer in layers)
            {
                if (layer.Value <= 0) continue;
                var height = chartHeight * layer.Value / maxValue;
                yBase -= height;
                <rect x="@x0" y="@yBase" width="@(unitW * 0.8)" height="@height" fill="@layer.Color" />
            }
        }
    </g>

    @* Average line *@
    <path fill="none" stroke="#FF0000" stroke-width="2"
          d="M @(
               string.Join(' ', Enumerable.Range(0,24)
                   .Select(h => {
                       var x = MarginLeft + unitW * (h + 0.5);
                       var y = MarginTop + chartHeight * (1 - HourlyConsumption[h] / maxValue);
                       return $"{x},{y}";
                   })))" />

    @* X-axis labels *@
    <g>
        @for (int h = 0; h < 24; h++)
        {
            var x = MarginLeft + unitW * (h + 0.5);
            <text x="@x" y="@(MarginTop + chartHeight + 27)" text-anchor="middle" fill="rgb(194,194,194)">@h.ToString("D2")</text>
        }
    </g>
</svg>

@* Code-behind: generator.cshtml.cs *@
@functions {
    public class HourlyCoverageViewModel
    {
        public required List<ConsumptionHour> ConsumptionHours { get; set; }
        public required double[] Matched { get; set; }
        public required double[] Unmatched { get; set; }
        public required double[] Overmatched { get; set; }
    }
}
