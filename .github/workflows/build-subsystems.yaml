name: Build Subsystems

on:
  workflow_call:
    inputs:
      dry-run:
        description: "An indication of whether to commit/publish results"
        required: true
        type: string
      is-dependabot:
        description: "An indication of a dependabot pull request"
        required: true
        type: string

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      test_matrix: ${{ steps.set_outputs.outputs.test_matrix }}
      docker_build_matrix: ${{ steps.set_outputs.outputs.docker_build_matrix }}
      configurations: ${{ steps.set_outputs.outputs.configurations }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Get changed domains
        id: get_changed_domains
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1 || true
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }} HEAD)
          echo "Changed files: $CHANGED_FILES"

          # Get list of all domains dynamically
          DOMAINS=$(find domains -mindepth 1 -maxdepth 1 -type d -exec basename {} \;)
          echo "All domains: $DOMAINS"

          # Determine changed domains
          DOMAINS_CHANGED=()
          for DOMAIN in $DOMAINS; do
            if echo "$CHANGED_FILES" | grep -q "^domains/$DOMAIN/"; then
              DOMAINS_CHANGED+=("$DOMAIN")
            fi
          done

          if [ ${#DOMAINS_CHANGED[@]} -eq 0 ]; then
            echo "No domains have changed."
            echo "changed_domains=" >> $GITHUB_ENV
          else
            echo "Changed domains: ${DOMAINS_CHANGED[@]}"
            changed_domains_str=$(printf '%s\n' "${DOMAINS_CHANGED[@]}")
            echo "changed_domains<<EOF" >> $GITHUB_ENV
            echo "$changed_domains_str" >> $GITHUB_ENV
            echo "EOF" >> $GITHUB_ENV
          fi

      - name: Create matrices and collect configurations
        id: set_outputs
        run: |
          set -e
          set -x
          echo "::group::Create matrices"
          TEST_MATRIX_JSON="[]"
          DOCKER_BUILD_MATRIX_JSON="[]"
          CONFIGURATIONS=""

          if [ -z "$changed_domains" ]; then
            echo "No domains to process."
          else
            declare -a TEST_MATRIX_ENTRIES
            declare -a DOCKER_BUILD_MATRIX_ENTRIES
            declare -a CONFIGURATION_FILES

            IFS=$'\n' read -r -a CHANGED_DOMAINS_ARRAY <<< "$changed_domains"

            for DOMAIN in "${CHANGED_DOMAINS_ARRAY[@]}"; do
              DOMAIN_PATH="domains/$DOMAIN"
              # Extract SDK and runtime versions from global.json
              GLOBAL_JSON="$DOMAIN_PATH/global.json"
              if [ -f "$GLOBAL_JSON" ]; then
                SDK_VERSION=$(jq -r '.sdk.version' "$GLOBAL_JSON")
                RUNTIME_VERSION=$(jq -r '.runtime.version' "$GLOBAL_JSON")
              else
                SDK_VERSION="latest"
                RUNTIME_VERSION="latest"
              fi

              # Find main projects in the domain
              while IFS= read -r -d '' csproj_file; do
                # Try to find configuration.yaml in the same directory or parent directories
                CONFIG_FILE=""
                CURRENT_DIR="${csproj_file%/*}"
                while [ "$CURRENT_DIR" != "$DOMAIN_PATH" ]; do
                  if [ -f "$CURRENT_DIR/configuration.yaml" ]; then
                    CONFIG_FILE="$CURRENT_DIR/configuration.yaml"
                    break
                  fi
                  CURRENT_DIR=$(dirname "$CURRENT_DIR")
                done
                if [ -z "$CONFIG_FILE" ]; then
                  echo "No configuration.yaml found for $csproj_file, skipping."
                  continue
                fi

                # Proceed to process the main project
                MAIN_PROJECT_NAME=$(basename "${csproj_file%.*}")
                TEMP_SOLUTION="${MAIN_PROJECT_NAME}_temp.sln"
                TEMP_SOLUTION_PATH="$DOMAIN_PATH/$TEMP_SOLUTION"

                dotnet new sln -n "$MAIN_PROJECT_NAME" -o "$DOMAIN_PATH"

                # Add the main project to the solution
                dotnet sln "$TEMP_SOLUTION_PATH" add "$csproj_file"

                # Find migration file if exists
                MIGRATION_FILE="${csproj_file%/*}/migrations/API.sql"
                if [ -f "$MIGRATION_FILE" ]; then
                  MIGRATION_FILE_PATH="$MIGRATION_FILE"
                else
                  MIGRATION_FILE_PATH=""
                fi

                # Prepare entry for test matrix
                TEST_MATRIX_ENTRY=$(jq -n \
                  --arg domain "$DOMAIN" \
                  --arg main_project "$csproj_file" \
                  --arg solution_path "$TEMP_SOLUTION_PATH" \
                  --arg sdk_version "$SDK_VERSION" \
                  '{domain: $domain, main_project: $main_project, solution_path: $solution_path, sdk_version: $sdk_version}')
                TEST_MATRIX_ENTRIES+=("$TEST_MATRIX_ENTRY")

                # Prepare entry for Docker build matrix
                DOCKER_BUILD_MATRIX_ENTRY=$(jq -n \
                  --arg domain "$DOMAIN" \
                  --arg main_project "$csproj_file" \
                  --arg solution_path "$TEMP_SOLUTION_PATH" \
                  --arg config_file "$CONFIG_FILE" \
                  --arg sdk_version "$SDK_VERSION" \
                  --arg runtime_version "$RUNTIME_VERSION" \
                  --arg migration_file "$MIGRATION_FILE_PATH" \
                  '{domain: $domain, main_project: $main_project, solution_path: $solution_path, config_file: $config_file, sdk_version: $sdk_version, runtime_version: $runtime_version, migration_file: $migration_file}')
                DOCKER_BUILD_MATRIX_ENTRIES+=("$DOCKER_BUILD_MATRIX_ENTRY")

                # Collect configuration files
                CONFIGURATION_FILES+=("$CONFIG_FILE")

              done < <(find "$DOMAIN_PATH" -type f -name "*.csproj" -print0)
            done

            # Build JSON arrays from entries
            if [ ${#TEST_MATRIX_ENTRIES[@]} -gt 0 ]; then
              TEST_MATRIX_JSON=$(printf '%s\n' "${TEST_MATRIX_ENTRIES[@]}" | jq -s '.')
            fi

            if [ ${#DOCKER_BUILD_MATRIX_ENTRIES[@]} -gt 0 ]; then
              DOCKER_BUILD_MATRIX_JSON=$(printf '%s\n' "${DOCKER_BUILD_MATRIX_ENTRIES[@]}" | jq -s '.')
            fi

            # Concatenate configuration file paths into a newline-separated list
            if [ ${#CONFIGURATION_FILES[@]} -gt 0 ]; then
              CONFIGURATIONS=$(printf '%s\n' "${CONFIGURATION_FILES[@]}" | sort | uniq)
            fi
          fi

          # Set outputs
          echo "test_matrix=$TEST_MATRIX_JSON" >> $GITHUB_OUTPUT
          echo "docker_build_matrix=$DOCKER_BUILD_MATRIX_JSON" >> $GITHUB_OUTPUT
          echo "configurations<<EOF" >> $GITHUB_OUTPUT
          echo "$CONFIGURATIONS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "::endgroup::"

  test:
    needs: setup
    strategy:
      fail-fast: false
      matrix:
        main_project: ${{ fromJson(needs.setup.outputs.test_matrix) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Test main project ${{ matrix.main_project.main_project }}
        uses: ./.github/actions/dotnet-test
        with:
          solution: ${{ matrix.main_project.solution_path }}
          sdk-version: ${{ matrix.main_project.sdk_version }}

  build:
    needs: setup
    strategy:
      fail-fast: false
      matrix:
        main_project: ${{ fromJson(needs.setup.outputs.docker_build_matrix) }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Build Docker image for ${{ matrix.main_project.main_project }}
        uses: ./.github/actions/dotnet-build
        with:
          solution: ${{ matrix.main_project.solution_path }}
          project: ${{ matrix.main_project.main_project }}
          configuration: ${{ matrix.main_project.config_file }}
          migrations: ${{ matrix.main_project.migration_file }}
          sdk-version: ${{ matrix.main_project.sdk_version }}
          runtime-version: ${{ matrix.main_project.runtime_version }}
          dry-run: ${{ inputs.dry-run }}
          is-dependabot: ${{ inputs.is-dependabot }}

  update:
    needs: [setup, build, test]
    runs-on: ubuntu-latest
    if: ${{ inputs.is-dependabot == 'false' && needs.setup.outputs.configurations != '' }}
    steps:
      - uses: actions/checkout@v3

      - name: Update environment
        uses: Energinet-DataHub/acorn-actions/actions/update-base-environment@v2
        with:
          configurations: ${{ needs.setup.outputs.configurations }}
          deploy_key: ${{ secrets.DEPLOY_KEY_BASE_ENVIRONMENT }}
          dry_run: ${{ inputs.dry-run }}
